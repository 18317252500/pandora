<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <title>使用和扩展 Metrics - 向未来出发</title>
  <meta charset="utf-8">
  <meta name="description" content="index.description">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
<link rel="stylesheet" href="/pandora/css/index.css">

</head>
<body>
  <div class="nav" >
  <header>
    <a href="/pandora/zh-cn" class="nav-logo leftpadding" alt="Pandora.js"><img src="/pandora/images/nav-logo.png" > Pandora.js</a>
    <ul class="nav-item">
      <li><a href="/pandora/zh-cn/introduce.html" alt="文档指南">文档指南</a></li><li><a href="/pandora/zh-cn/api.html" alt="API 接口">API 接口</a></li><li><a href="https://github.com/midwayjs/pandora/releases" alt="发布日志">发布日志</a></li>
      <li class="translations">
        <a class="nav-link">中文</a>
        <span class="arrow" style="border-top-color:#fff" ></span>
        <ul class="dropdown-content" >
          <li style="display: block; margin-left: 20px" ><a style="color: #008ce6" href="/pandora/zh-cn">中文</a></li>
          <li style="display: block; margin-left: 20px" ><a style="color: #008ce6" href="/pandora/en">English</a></li>
        </ul>
      </li>
      <li><iframe src="https://ghbtns.com/github-btn.html?user=midwayjs&repo=pandora&type=star&count=true" frameborder="0" scrolling="0" width="150px" height="20px"></iframe></li>
    </ul>
    <a id="mobileTrigger" href="#" class="mobile-trigger">
      <ul>
        <li></li>
        <li></li>
        <li></li>
      </ul>
    </a>
  </header>
</div>

  <div id="container" class="container">
    <div class="page-main">
  <article class="markdown-body">
    <h1>使用和扩展 Metrics</h1>
    <p>Metrics 是监控里面比较大的一个体系，它基于 EndPoint 体系来传输数据，同时在这个基础上做了很多封装的工作。</p>
<p>Metrics 的原意是 <strong>指标</strong>，用于反馈应用的当前状况的数据值，所以 Metrics 最后的结果都是<strong>数字</strong>。</p>
<p>在业界标准的 Metrics 类型中，有几种标准的类型。</p>
<ul>
<li>Gauge 瞬时值</li>
<li>Counter 计数器</li>
<li>Meter 吞吐率度量器</li>
<li>Histogram 直方分布度量器</li>
</ul>
<p>Pandora.js 目前对这几种度量器都做了一定的支持，这些度量器中最常用的就是 Gauge 和 Counter，可以说，80% 的场景都只是用这两种。</p>
<h2 id="快速使用"><a class="markdown-anchor" href="#快速使用">#</a> 快速使用</h2>
<p>我们在每个进程启动时创建了一个 <code>MetricsClient</code> 客户端，但是用户怎么在代码中拿到这个对象就成了一个问题，我们设计了一个代理类 <code>MetricsClientUtil</code> ，只要用户希望，就可以在任意地方获取到这个类，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;MetricsClientUtil&#125; <span class="keyword">from</span> <span class="string">'dorapan'</span>;</span><br><span class="line"><span class="keyword">const</span> client = MetricsClientUtil.getMetricsClient();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> counter = client.getCounter(<span class="string">'test'</span>, <span class="string">'test.qps.counter'</span>);</span><br><span class="line"><span class="keyword">let</span> histogram = client.getHistogram(<span class="string">'test'</span>, <span class="string">'test.qps.histogram'</span>);</span><br><span class="line"><span class="keyword">let</span> meter = client.getMeter(<span class="string">'test'</span>, <span class="string">'test.qps.meter'</span>);</span><br><span class="line"><span class="keyword">let</span> timer = client.getTimer(<span class="string">'test'</span>, <span class="string">'test.qps.timer'</span>);</span><br><span class="line"> </span><br><span class="line">counter.inc(<span class="number">1</span>);</span><br><span class="line">counter.dec(<span class="number">1</span>);</span><br><span class="line">histogram.update(<span class="number">5</span>);</span><br><span class="line">meter.mark(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>通过 <code>Client</code> 和 Get 对应的度量类型方法，这样在任意地方，用户都可以随时随地埋入 Metrics 指标，如果想知道埋入的效果，可以通过 <code>/metrics/:group</code> 这样的路由看到结果，更多的路由方法可以参考 <a href="/monitor/resource.html">Reource</a>。</p>
<blockquote>
<p>注意：所有的 Metric 实例，都必须注册到当前进程的 MetricsClient 上才能被采集到。</p>
</blockquote>
<p>由于 Gauge 指标的特殊性，Client 无法通过类似的 getGauge 方法创建 Gauge 类型的指标，所以有了通用的 <code>register()</code> 方法，定义如下，也可以<a href="http://www.midwayjs.org/pandora/api-reference/metrics/classes/metricsclient.html#register" target="_blank" rel="noopener">查看 API</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">client.register(group: string, <span class="attr">name</span>: MetricName | string, Metric);</span><br></pre></td></tr></table></figure>
<p>根据定义，我们可以这样添加 Gauge 类型的指标。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client.register(&apos;test&apos;, name, &#123;</span><br><span class="line">  getValue() &#123;</span><br><span class="line">  	return 100;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="指标的名字-metricname"><a class="markdown-anchor" href="#指标的名字-metricname">#</a> 指标的名字 MetricName</h2>
<p>每一个指标都可以取一个名字，这个名字在 Pandora.js 并不是简单的字符串，而是一个 MetricName 类型的实现。</p>
<p>这个类的属性参见 <a href="http://www.midwayjs.org/pandora/api-reference/metrics/classes/metricname.html" target="_blank" rel="noopener">API 这里</a>。</p>
<p>常见的是 key 和 tags 两部分。</p>
<p>key 就是标准的字符串，一般由几个字符串通过 . 来拼接而成。而 tags 是一组对象 kv 对，key 加 tags 标识了唯一的一个 Metric。</p>
<p>还有一部分是 MetricsLevel，不同的 MetricsLevel 对应了不同的指标缓存时间，默认时间如下，单位为秒。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getCachedTimeForLevel(level: MetricLevel) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (level) &#123;</span><br><span class="line">    <span class="keyword">case</span> MetricLevel.TRIVIAL:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">case</span> MetricLevel.MINOR:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">case</span> MetricLevel.NORMAL:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">case</span> MetricLevel.MAJOR:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> MetricLevel.CRITICAL:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，假如你的指标等级是 <code>MetricLevel.MAJOR</code>，那么缓存时间为 2 秒，如果你的采集周期是 1 秒的话，那么在两次采集窗口的时候，返回的值都是相同的。</p>
<h2 id="度量类型"><a class="markdown-anchor" href="#度量类型">#</a> 度量类型</h2>
<blockquote>
<p>目前 Pandora.js 全部使用 typescript 来编写，有些代码必须带类型定义。</p>
<p>所有的 Metric 类型都继承与 <a href="http://www.midwayjs.org/pandora/api-reference/metrics/interfaces/metric.html" target="_blank" rel="noopener">Metric 接口</a></p>
</blockquote>
<h3 id="瞬态型度量指标"><a class="markdown-anchor" href="#瞬态型度量指标">#</a> 瞬态型度量指标</h3>
<p>大部分的度量指标都从瞬态值 Gauge 介绍起，因为它最简单，最直观的表示数据的真实情况，也不涉及时间间隔的问题。</p>
<p>Gauge 只包含一个 <code>getValue</code> 方法，只需要实现这个方法即可，比如，你想要知道当前进程的 cpu 使用情况，就可以一句话解决。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;BaseGauge&gt; &#123;</span><br><span class="line">  getValue() &#123;</span><br><span class="line">  	<span class="keyword">const</span> startUsage = process.cpuUsage();</span><br><span class="line">    <span class="keyword">return</span> startUsage.user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，所有的 Metrics 最终输出的一定是数字形式，这样才可度量，如果你希望输出的是字符串类的信息，我们有另一套输出体系，这将在之后的文章介绍。</p>
</blockquote>
<h3 id="累加型度量指标"><a class="markdown-anchor" href="#累加型度量指标">#</a> 累加型度量指标</h3>
<p>Counter 是第二个介绍的类型，计数器和 Gauge 不太一样，它是累加型，适用于记录调用总量等类型的数据，比如某个接口的调用次数。</p>
<p>如下图是计数器的继承接口和实现类。</p>
<p><img src="https://img.alicdn.com/tfs/TB1OkX3ldrJ8KJjSspaXXXuKpXa-780-732.png" alt=""></p>
<p>除了基础的 <code>BaseCounter</code> 实现之外，我们提供了 <code>BucketCounter</code> 分桶计数器。</p>
<p>分桶计数的原理是定义一个时间间隔，将一段时间按照时间间隔分割为几个桶，每个桶保存当前时间间隔的计数。</p>
<p>比如时间间隔为 5s ，桶的总数为 10 个，那么 0~5s 为一个桶，5~10s 为下一个，以此类推。当计数的执行的时间为 2s 时，那么将在第一桶中累加，如果为 7s 时，那么将在第二个桶累加，非常容易理解。</p>
<p>在实际场景中，因为内存限制，不宜保存过多，桶的量会有限制，采用环形队列存储同时避免数据的挪动。</p>
<p>举个常用例子，记录 koa 服务的请求数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际使用需要从 MetricsClient 拿到 BucketCounter</span></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> BucketCounter();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 累加 1 counter.inc(1);</span></span><br><span class="line">  counter.inc();</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="分布度量指标"><a class="markdown-anchor" href="#分布度量指标">#</a> 分布度量指标</h3>
<p>第三个介绍的是 Histogram，直方分布指标，Pandora.js 包含一个基础实现类 <code>BaseHistogram</code>， 通过它可以用于统计某个接口的响应时间，可以展示 50%, 70%, 90% 的请求响应时间落在哪个区间内，通过这些你可以计算出 <a href="https://en.wikipedia.org/wiki/Apdex" target="_blank" rel="noopener">Apdex</a>。</p>
<blockquote>
<p>这边的分布暂时只考虑单机分布，在集群维度上不能这样计算。</p>
</blockquote>
<p>对于分布计算，核心就是维护一个数据集 <a href="http://www.midwayjs.org/pandora/api-reference/metrics/enums/reservoirtype.html" target="_blank" rel="noopener">Reservoir</a> ，数据集用来提供数据存储以及获取当前快照的能力。这其中最重要的就是数据更新的策略，目前 Pandora.js 只实现了随机采样（UniformReservoir）和 指数衰减随机采样（ExponentiallyDecayingReservoir）的实现，由于随机采样并不能很好的表现权重问题，默认的是指数衰减随机采样，其他的采样算法没有实现，有兴趣的同学可以补充。</p>
<p>举个常用例子，记录 koa 服务的成功比率，采用随机采样算法，间隔 1s，2个分桶，展示获取了平均数等信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际使用需要从 MetricsClient 拿到 BaseHistogram</span></span><br><span class="line"><span class="keyword">let</span> histogram = <span class="keyword">new</span> BaseHistogram(ReservoirType.UNIFORM, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  histogram.update(<span class="number">10</span>);</span><br><span class="line">  histogram.update(<span class="number">20</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// other biz</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// let snapshot = histogram.getSnapshot();</span></span><br><span class="line"><span class="comment">// expect(snapshot.getMean()).to.equal(15);</span></span><br><span class="line"><span class="comment">// expect(snapshot.getMax()).to.equal(20);</span></span><br><span class="line"><span class="comment">// expect(snapshot.getMin()).to.equal(10);</span></span><br><span class="line"><span class="comment">// expect(snapshot.getMedian()).to.equal(15);</span></span><br></pre></td></tr></table></figure>
<h3 id="变化速率度量指标"><a class="markdown-anchor" href="#变化速率度量指标">#</a> 变化速率度量指标</h3>
<p>第四个介绍的是 Meter，是一种用于度量一段时间内吞吐率的计量器。例如，一分钟内，五分钟内，十五分钟内的qps指标。</p>
<p>这里要指出，变化的速率，我们一般情况下会关心两个地方，一个是瞬时爆发，超出平常正常值非常高的这样的波动变化，另一个是一段时间内的趋势，从平均的角度来看整体度量的一种方式，这种方式会将高低点进行平均来看。</p>
<p>前一种在  Metrics 中使用  Rate 的概念，只记录事件的累计总次数，有外部系统来通过前后两次采集，来计算瞬时速率，这里我们称之为<code>Rate</code>。</p>
<p>在rate的计算中，我们认为数据的增长是<code>线性</code>的。其计算方式为：rate = (v2 - v1) / (t2 - t1)，其中时间的单位是 s。</p>
<p>这样的好处是，通过调整采集频率，可以支持任意时间间隔的瞬时速率计算。但缺点是，当两次采样之间系统重启的时候，会计算出负数，同时会有一部分数据丢失。</p>
<p>后一种通过指数移动加权平均(Exponential Weighted Moving Average, EWMA）来计算。</p>
<p>针对速率型度量指标，我们提供了1分钟(m1)，5分钟(m5)，15分钟的EWMA(m15)，分别用于反映距离当前时间点1分钟，5分钟，15分钟的速率变化。</p>
<p>其具体的计算方法，和 Linux 系统中 load1, load5, load15 的计算方法完全一致。即，每 5 秒钟统计一次瞬时速率，并应用于如下的递推公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EWMA(t) = EWMA(t-1) + alpha * (instantRate - EWMA(t-1))</span><br></pre></td></tr></table></figure>
<p>其中 alpha取值范围为 0~1, 称为衰减系数，该系数越大，则距离当前的时间点越老的数据权重衰减的越快。</p>
<p>举个常用例子，记录 koa 某个路由的调用比率。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际使用需要从 MetricsClient 拿到 BaseMeter</span></span><br><span class="line"><span class="keyword">let</span> meter = <span class="keyword">new</span> BaseMeter();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/home'</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 接口调用埋点</span></span><br><span class="line">  meter.mark(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// meter.getMeanRate(); 总数除以时间</span></span><br><span class="line"><span class="comment">// meter.getOneMinuteRate(); // 一分钟的 EWMA</span></span><br></pre></td></tr></table></figure>
<h2 id="聚合型度量指标"><a class="markdown-anchor" href="#聚合型度量指标">#</a> 聚合型度量指标</h2>
<p>这里引进一种特殊的指标，他相当于是多个指标的聚合。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> abstract <span class="class"><span class="keyword">class</span> <span class="title">MetricSet</span> <span class="title">implements</span> <span class="title">Metric</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  type: string = MetricType.METRICSET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * A map of metric names to metrics.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return the metrics</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  abstract getMetrics(): <span class="built_in">Array</span>&lt;&#123;</span><br><span class="line">    name,</span><br><span class="line">    metric</span><br><span class="line">  &#125;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MetricSet 包含了一个抽象的 <code>getMetrics()</code> 方法，用于返回最终的多个 Metrics，我们利用它实现了一个上层 <code>CachedMetricSet</code>，用于将指标通过不同的 MetricsLevel 缓存一段时间。</p>
<p>这里举个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCachedMetricSet</span> <span class="keyword">extends</span> <span class="title">CachedMetricSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  caches;</span><br><span class="line"></span><br><span class="line">  getValueInternal() &#123;</span><br><span class="line">    <span class="keyword">this</span>.caches = &#123;</span><br><span class="line">      a: <span class="built_in">Math</span>.random(),</span><br><span class="line">      b: <span class="built_in">Math</span>.random(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getMetrics() &#123;</span><br><span class="line">    <span class="keyword">let</span> results = [];</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    results.push(&#123;</span><br><span class="line">      name: MetricName.build(<span class="string">'test.a'</span>),</span><br><span class="line">      metric: &lt;BaseGauge&lt;any&gt;&gt; &#123;</span><br><span class="line">        async getValue() &#123;</span><br><span class="line">          await self.refreshIfNecessary();</span><br><span class="line">          return self.caches['a'];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    results.push(&#123;</span><br><span class="line">      name: MetricName.build('test.b'),</span><br><span class="line">      metric: &lt;GaugeProxy&lt;any&gt;&gt; &#123;</span><br><span class="line">        async getValue() &#123;</span><br><span class="line">          await self.refreshIfNecessary();</span><br><span class="line">          return self.caches['b'];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return results;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过 <code>getMetrics()</code> 方法返回了两个 Gauge 指标，这两个指标通过内部缓存的值进行返回， <code>refreshIfNecessary()</code> 用于将内部的缓存值进行刷新操作。</p>
<p>内置的大部分指标像 CPU、内存等等都是基于 <code>CachedMetricSet</code> 来实现的，更多的可以参考<a href="http://www.midwayjs.org/pandora/api-reference/metrics/classes/cpuusagegaugeset.html" target="_blank" rel="noopener">代码</a>实现。</p>
<blockquote>
<p>虽然注册时是一个指标，但是最后展示会进行分解，变成几个单独的指标</p>
</blockquote>

  </article>
  <aside id="mobileAside" class="toc">
  <div class="mobile-menu">
    <ul><li><a href="/pandora/zh-cn/introduce.html" alt="文档指南">文档指南</a></li><li><a href="/pandora/zh-cn/api.html" alt="API 接口">API 接口</a></li><li><a href="https://github.com/midwayjs/pandora/releases" alt="发布日志">发布日志</a></li></ul>
  </div>
  <dl><dt><a href="/pandora/zh-cn/introduce.html">Pandora.js 是什么？</a></dt></ul></dd><dt><a href="/pandora/zh-cn/quickstart.html">快速入门</a></dt></ul></dd><dt><a href="/pandora/zh-cn/glossary.html">关键术语</a></dt></ul></dd><dt>基础功能</dt><dd><ul><li><a href="/pandora/zh-cn/base/command.html">命令行介绍</a></li><li><a href="/pandora/zh-cn/other/dashboard.html">可视化管理面板</a></li><li><a href="/pandora/zh-cn/base/procfile_mode.html">认识 procfile.js</a></li><li><a href="/pandora/zh-cn/base/dorapan.html">用户空间 SDK - Dorapan</a></li><li><a href="/pandora/zh-cn/base/logs.html">日志管理</a></li><li><a href="/pandora/zh-cn/base/global_config.html">配置文件</a></li><li><a href="/pandora/zh-cn/base/quick_monitor.html">快速了解监控</a></li><li><a href="/pandora/zh-cn/base/debug.html">调试应用</a></li></ul></dd><dt>进程管理进阶</dt><dd><ul><li><a href="/pandora/zh-cn/process/process_std.html">自定义进程</a></li><li><a href="/pandora/zh-cn/process/service_std.html">自定义 Service</a></li><li><a href="/pandora/zh-cn/process/fork_and_cluster.html">Fork 和 Cluster</a></li><li><a href="/pandora/zh-cn/process/environment_std.html">自定义环境</a></li><li><a href="/pandora/zh-cn/process/application_life_cycle.html">应用生命周期</a></li><li><a href="/pandora/zh-cn/process/ipc_hub.html">进程间通信</a></li></ul></dd><dt>应用监控</dt><dd><ul><li><a href="/pandora/zh-cn/monitor/monitor_std.html">监控体系总览</a></li><li><a href="/pandora/zh-cn/monitor/endpoint.html">使用和扩展 EndPoint</a></li><li><a href="/pandora/zh-cn/monitor/resource.html">对外暴露 Resource</a></li><li><a href="/pandora/zh-cn/monitor/metrics.html">使用和扩展 Metrics</a></li><li><a href="/pandora/zh-cn/monitor/trace.html">链路监控</a></li><li><a href="/pandora/zh-cn/monitor/monitor_inner.html">默认监控</a></li><li><a href="/pandora/zh-cn/monitor/report.html">监控数据上报</a></li></ul></dd><dt>监控数据采集</dt><dd><ul><li><a href="/pandora/zh-cn/collect/health.html">健康检查</a></li></ul></dd><dt>扩展功能</dt><dd><ul><li><a href="/pandora/zh-cn/other/typescript.html">启动 TypeScript 项目</a></li></ul></dd></dl>
</aside>
<script>
var mobileTrigger = document.getElementById('mobileTrigger');
var mobileAside = document.getElementById('mobileAside');
mobileTrigger.onclick = function(e) {
  e.preventDefault();
  if (mobileAside.className.indexOf('mobile-show') === -1) {
    mobileAside.className += ' mobile-show';
  } else {
    mobileAside.className = 'toc';
  }
};
</script>

</div>

  </div>
</body>
<div class="cnzz">
<script src="https://s19.cnzz.com/z_stat.php?id=1271324644&web_id=1271324644" language="JavaScript"></script>
</div>

</html>
